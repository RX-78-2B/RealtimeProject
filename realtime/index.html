<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Realtime Project</title>
        <!-- Babylon.js -->
        <script src="hand.minified-1.2.js"></script>
        <script src="cannon.js"></script>
        <script src="oimo.js"></script>
		<script src="babylon.js"></script>
		<script src="grass/fongfilm.js" type="text/javascript"></script>
		<script id="vertexShader" type="x-shader/x-vertex">
			#ifdef GL_ES
			precision mediump float;
			#endif
			 
			// Attributes
			attribute vec3 position;
			attribute vec3 normal;
			attribute vec2 uv;
			 
			// Uniforms
			uniform vec2 waveData;
			uniform mat4 windMatrix;
			uniform mat4 world;
			uniform mat4 worldViewProjection;
			 
			// Normal
			varying vec3 vPositionW;
			varying vec3 vNormalW;
			varying vec4 vUV;
			varying vec2 vBumpUV;
			 
			void main(void) {
				vec4 outPosition = worldViewProjection * vec4(position, 1.0);
				gl_Position = outPosition;
			 
				vPositionW = vec3(world * vec4(position, 1.0));
				vNormalW = normalize(vec3(world * vec4(normal, 0.0)));
			 
				vUV = outPosition;
			 
				vec2 bumpTexCoord = vec2(windMatrix * vec4(uv, 0.0, 1.0));
				vBumpUV = bumpTexCoord / waveData.x;
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-vertex">
		#ifdef GL_ES
		precision mediump float;
		#endif
		uniform vec3 vEyePosition;
		uniform vec4 vLevels;
		uniform vec3 waterColor;
		uniform vec2 waveData;	 
		// Lights
		varying vec3 vPositionW;
		varying vec3 vNormalW;
		uniform vec3 vLightPosition;		 
		// Refs
		varying vec2 vBumpUV;
		varying vec4 vUV;
		uniform sampler2D refractionSampler;
		uniform sampler2D reflectionSampler;
		uniform sampler2D bumpSampler;		 
		void main(void) {
			vec3 viewDirectionW = normalize(vEyePosition - vPositionW);
		 
			// Light
			vec3 lightVectorW = normalize(vLightPosition - vPositionW);
		  
			// Wave
			vec3 bumpNormal = 2.0 * texture2D(bumpSampler, vBumpUV).rgb - 1.0;
			vec2 perturbation = waveData.y * bumpNormal.rg;
		 
			// diffuse
			float ndl = max(0., dot(vNormalW, lightVectorW));
		 
			// Specular
			vec3 angleW = normalize(viewDirectionW + lightVectorW);
			float specComp = dot(normalize(vNormalW), angleW);
			specComp = pow(specComp, 256.);
		 
			// Refraction
			vec2 texCoords;
			texCoords.x = vUV.x / vUV.w / 2.0 + 0.5;
			texCoords.y = vUV.y / vUV.w / 2.0 + 0.5;
		 
			vec3 refractionColor = texture2D(refractionSampler, texCoords + perturbation).rgb;
		 
			// Reflection
			vec3 reflectionColor = texture2D(reflectionSampler, texCoords + perturbation).rgb;
		 
			// Fresnel
			float fresnelTerm = dot(viewDirectionW, vNormalW);
			fresnelTerm = clamp((1.0 - fresnelTerm) * vLevels.y, 0., 1.);
		 
			// Water color
		 
			vec3 finalColor = (waterColor * ndl) * vLevels.x + (1.0 - vLevels.x) * (reflectionColor * fresnelTerm * vLevels.z + 
															   (1.0 - fresnelTerm) * refractionColor * vLevels.w) + specComp;
		 
			gl_FragColor = vec4(finalColor, 1.);
		}
		</script>
		<script src="Water/waterMaterial.js"></script>
		<script src="Fire/fireMaterial.js"></script>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);
		
		
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
			scene.collisionsEnabled = true;
			//scene.clearColor = new BABYLON.Color3(0.5, 0.8, 0.5);
			//scene.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            //Create a light
            //var light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(0.5, -1, -0.5), scene);
        	var  light = new BABYLON.PointLight("dir01", new BABYLON.Vector3(60, 100, 10), scene);
            //Create an Arc Rotate Camera - aimed negative z this time
            var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
			camera.checkCollisions = true;
			camera.position=new BABYLON.Vector3(0, 1, -70);
            camera.rotation=new BABYLON.Vector3(0,0,0);
        
            //Fong â˜º Film
			
            var plane = BABYLON.Mesh.CreateGround("plane", 500, 500, 1, scene, false);
			BABYLON.Utils.makePlanarMapping(plane, 0.4);
			plane.position.y = -60;
			
			BABYLON.Engine.ShadersRepository = "./grass/";
			var grass = new BABYLON.GrassMaterial("grass", scene,"16.0", "256.0");
			grass.bladesTexture = new BABYLON.Texture("grass/s_grassblades.tga", scene, false, false);
			grass.groundTexture = new BABYLON.Texture("textures/grass.jpg", scene);
			grass.windTexture = new BABYLON.Texture("grass/windnoise.tga", scene, false, false);
			plane.material = grass;
            
            //Ground
            var plane = BABYLON.Mesh.CreateGround("plane", 500, 500, 1, scene, false);
            plane.position.y = -6;
            //Creation of a repeated textured material
            var materialPlane = new BABYLON.StandardMaterial("texturePlane", scene);
            materialPlane.diffuseTexture = new BABYLON.Texture("textures/grass.jpg", scene);
            materialPlane.diffuseTexture.uScale = 50.0;//Repeat 50 times on the Vertical Axes
            materialPlane.diffuseTexture.vScale = 50.0;//Repeat 50 times on the Horizontal Axes
            //materialPlane.backFaceCulling = false;//Always show the front and the back of an element
			//plane.renderingGroupId = 1;
			plane.material = materialPlane;
			
            //Sky&Fog
            var skybox = BABYLON.Mesh.CreateBox("skyBox", 500.0, scene);
			var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
			skyboxMaterial.backFaceCulling = false;
			skyboxMaterial.disableLighting = true;
			skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
			skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
			skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
			skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
			skybox.material = skyboxMaterial;
			skybox.infiniteDistance = true;
			//skybox.renderingGroupId = 0;
			scene.registerBeforeRender(function () {
				skybox.rotation.y += 0.0001;	
				if(camera.position.y <0) camera.position.y =0;
				//if(camera.position.y >0) camera.position.y =0;
				if(camera.rotation.x <-Math.PI/3) camera.rotation.x =-Math.PI/3;
				if(camera.rotation.x >Math.PI/3) camera.rotation.x =Math.PI/3;
				});
			//scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
			//scene.fogDensity = 0.004;
			//scene.fogColor = new BABYLON.Color3(0.9, 0.9, 0.85);
			 // water shading
			BABYLON.Engine.ShadersRepository="";
			var water = BABYLON.Mesh.CreateGround("water", 34, 38, 1, scene, false);	
			var waterMaterial = new WaterMaterial("water", scene, light);			 
			  water.position.x=125;
			  	water.position.z=2;
			   water.position.y=4.75-3.5;
			
			 //-----------
		
			//---------Loading Object
			 BABYLON.SceneLoader.ImportMesh("", "", "campfire.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			
			 newMeshes[0].position = new BABYLON.Vector3(80, -5.75, -120);
			 newMeshes[0].checkCollisions=true;
			  newMeshes[0].scaling.x=2;
			  newMeshes[0].scaling.y=2;
			   newMeshes[0].scaling.z=2;
			 //newMeshes[0].renderingGroupId = 2;
				});		
			  	
			waterMaterial.reflectionTexture.renderList.push(skybox);	
			var pool = BABYLON.SceneLoader.ImportMesh("", "", "pool.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			  waterMaterial.reflectionTexture.renderList.push(newMeshes[0]);
			  newMeshes[0].position.x=100;
			  
			  newMeshes[0].position.y=0-2.5;
			 // newMeshes[0].renderingGroupId = 2;
				});		
				/*var fountainob = BABYLON.SceneLoader.ImportMesh("", "", "fountain.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			  waterMaterial.reflectionTexture.renderList.push(newMeshes[0]);
			  newMeshes[0].position.x=-100;
			  newMeshes[0].position.z=-100;
			  newMeshes[0].position.y=-5;
			 // newMeshes[0].renderingGroupId = 2;
				});	*/	
			// set reflection 
			waterMaterial.reflectionTexture.renderList.push(plane);				
			waterMaterial.reflectionTexture.renderList.push(skybox);		
			water.material = waterMaterial;
			// ------------
			
			/*BABYLON.SceneLoader.ImportMesh("", "", "wall.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			newMeshes[0].position.x=20;
			newMeshes[0].position.y=-5;
			newMeshes[0].position.z=-4;
			newMeshes[0].checkCollisions=true;
			newMeshes[0].rotation=new BABYLON.Vector3(0,1.5,0);
				});*/
				
			//wall
			var PlaneMat = new BABYLON.StandardMaterial('ground', scene);
			PlaneMat.diffuseTexture = new BABYLON.Texture('textureWood.jpg', scene);
			
			var PlaneMat1 = new BABYLON.StandardMaterial('ground', scene);
			PlaneMat1.diffuseTexture = new BABYLON.Texture('floor.jpg', scene);
			
			var plane = BABYLON.Mesh.CreatePlane("plane", 100.0, scene);	
			plane.position = new BABYLON.Vector3(0, -5, 0);
			plane.rotation.x = Math.PI/2;
			plane.material = PlaneMat1;
			plane.backFaceCulling = true;
			
			var plane1 = BABYLON.Mesh.CreatePlane("plane", 100.0, scene);	
			plane1.position = new BABYLON.Vector3(0, -5, 50);
			plane1.material = PlaneMat;
			plane1.checkCollisions=true;
			plane1.backFaceCulling = true;
			
			//
			var plane1 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane1.position = new BABYLON.Vector3(-30, -5, 0);
			plane1.material = PlaneMat;
			plane1.checkCollisions=true;
			plane1.backFaceCulling = true;
			var plane1 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane1.position = new BABYLON.Vector3(-30, 25, 0);
			plane1.material = PlaneMat;
			plane1.checkCollisions=true;
			plane1.backFaceCulling = true;
			
			//			
			var plane1 = BABYLON.Mesh.CreatePlane("plane", 20.0, scene);	
			plane1.position = new BABYLON.Vector3(40, -5, 10);
			plane1.material = PlaneMat;
			plane1.checkCollisions=true;
			plane1.backFaceCulling = true;
			var plane1 = BABYLON.Mesh.CreatePlane("plane", 20.0, scene);	
			plane1.position = new BABYLON.Vector3(40, 15, 10);
			plane1.material = PlaneMat;
			plane1.checkCollisions=true;
			plane1.backFaceCulling = true;
			var plane1 = BABYLON.Mesh.CreatePlane("plane", 20.0, scene);	
			plane1.position = new BABYLON.Vector3(40, 35, 10);
			plane1.material = PlaneMat;
			plane1.checkCollisions=true;
			plane1.backFaceCulling = true;
			
			//
			var plane2 = BABYLON.Mesh.CreatePlane("plane", 100.0, scene);	
			plane2.position = new BABYLON.Vector3(50, -5, 0);
			plane2.rotation.y = Math.PI/2;
			plane2.material = PlaneMat;
			plane2.checkCollisions=true;
			plane2.backFaceCulling = true;
			
			//
			var plane2 = BABYLON.Mesh.CreatePlane("plane", 50.0, scene);	
			plane2.position = new BABYLON.Vector3(10, -5, 25);
			plane2.rotation.y = Math.PI/2;
			plane2.material = PlaneMat;
			plane2.checkCollisions=true;
			plane2.backFaceCulling = true;
			var plane2 = BABYLON.Mesh.CreatePlane("plane", 50.0, scene);	
			plane2.position = new BABYLON.Vector3(10, 25, 25);
			plane2.rotation.y = Math.PI/2;
			plane2.material = PlaneMat;
			plane2.checkCollisions=true;
			plane2.backFaceCulling = true;
			
			var plane2 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane2.position = new BABYLON.Vector3(10, -5, -30);
			plane2.rotation.y = Math.PI/2;
			plane2.material = PlaneMat;
			plane2.checkCollisions=true;
			plane2.backFaceCulling = true;
			var plane2 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane2.position = new BABYLON.Vector3(10, 25, -30);
			plane2.rotation.y = Math.PI/2;
			plane2.material = PlaneMat;
			plane2.checkCollisions=true;
			plane2.backFaceCulling = true;
			
			var plane2 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane2.position = new BABYLON.Vector3(-10, -5, -30);
			plane2.rotation.y = Math.PI/2;
			plane2.material = PlaneMat;
			plane2.checkCollisions=true;
			plane2.backFaceCulling = true;
			var plane2 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane2.position = new BABYLON.Vector3(-10, 25, -30);
			plane2.rotation.y = Math.PI/2;
			plane2.material = PlaneMat;
			plane2.checkCollisions=true;
			plane2.backFaceCulling = true;
			
			//
			var plane3 = BABYLON.Mesh.CreatePlane("plane", 100.0, scene);	
			plane3.position = new BABYLON.Vector3(-50, -5, 0);
			plane3.rotation.y = Math.PI/2;
			plane3.material = PlaneMat;
			plane3.checkCollisions=true;
			plane3.backFaceCulling = true;
			
			var plane4 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane4.position = new BABYLON.Vector3(30, -5, -50);
			plane4.material = PlaneMat;
			plane4.checkCollisions=true;
			plane4.backFaceCulling = true;
			var plane4 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane4.position = new BABYLON.Vector3(30, 25, -50);
			plane4.material = PlaneMat;
			plane4.checkCollisions=true;
			plane4.backFaceCulling = true;
			
			var plane5 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane5.position = new BABYLON.Vector3(-30, -5, -50);
			plane5.material = PlaneMat;
			plane5.checkCollisions=true;
			plane5.backFaceCulling = true;
			var plane5 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane5.position = new BABYLON.Vector3(-30, 25, -50);
			plane5.material = PlaneMat;
			plane5.checkCollisions=true;
			plane5.backFaceCulling = true;
			
			//bed room
			BABYLON.SceneLoader.ImportMesh("", "", "bedRoom//bed.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			for (j = 0; j < newMeshes.length; j++) {                               
                                if(j<7){
									newMeshes[j].position.x = -30;
									newMeshes[j].position.y = 0;
									newMeshes[j].position.z = 23;
									newMeshes[j].checkCollisions=true;
									newMeshes[j].rotation=new BABYLON.Vector3(0,0.5,0);			
								}
								else{
									newMeshes[j].position.x = -35;
									newMeshes[j].position.y = 0;
									newMeshes[j].position.z = 35;
									newMeshes[j].checkCollisions=true;
									newMeshes[j].rotation=new BABYLON.Vector3(0,1,0);
								}
                            }
				});
				
			//bath room
			BABYLON.SceneLoader.ImportMesh("", "", "bathRoom//toilet.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			newMeshes[0].position.x=20;
			newMeshes[0].position.y=-5;
			newMeshes[0].position.z=0;
			newMeshes[0].checkCollisions=true;
				});
				
			BABYLON.SceneLoader.ImportMesh("", "", "bathRoom//bath.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			for (j = 0; j < newMeshes.length; j++) {                               
									newMeshes[j].position.x = 30;
									newMeshes[j].position.y = -5;
									newMeshes[j].position.z = 35;
									newMeshes[j].checkCollisions=true;
									//newMeshes[j].rotation=new BABYLON.Vector3(0,0.5,0);			
                            }
				});
				
			var plane1 = BABYLON.Mesh.CreatePlane("plane", 40.0, scene);	
			plane1.position = new BABYLON.Vector3(30, -3, 30);
			plane1.rotation.x = Math.PI/2; 
			
			BABYLON.SceneLoader.ImportMesh("", "", "bathRoom//sink.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			newMeshes[0].position.x=21;
			newMeshes[0].position.y=0;
			newMeshes[0].position.z=0;
			newMeshes[0].checkCollisions=true;
				});
				
			BABYLON.SceneLoader.ImportMesh("", "", "bathRoom//towelRail.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			newMeshes[0].position.x=30;
			newMeshes[0].position.y=5;
			newMeshes[0].position.z=50;
			newMeshes[0].checkCollisions=true;
				});
				
			//living room
			BABYLON.SceneLoader.ImportMesh("", "", "livingRoom//shelf.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			for (j = 0; j < newMeshes.length; j++) { 
				newMeshes[j].position.x=30;
				newMeshes[j].position.y=0;
				newMeshes[j].position.z=-40;
				newMeshes[j].checkCollisions=true;
				}
				});
				
			BABYLON.SceneLoader.ImportMesh("", "", "livingRoom//sofa.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			for (j = 0; j < newMeshes.length; j++) { 
				newMeshes[j].position.x=30;
				newMeshes[j].position.y=-5;
				newMeshes[j].position.z=-5;
				newMeshes[j].checkCollisions=true;
				}
				});
				
			BABYLON.SceneLoader.ImportMesh("", "", "livingRoom//tv.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			for (j = 0; j < newMeshes.length; j++) { 
				newMeshes[j].position.x=30;
				newMeshes[j].position.y=0;
				newMeshes[j].position.z=-40;
				newMeshes[j].checkCollisions=true;
				newMeshes[j].rotation=new BABYLON.Vector3(0,Math.PI,0);
				}
				});
				
			BABYLON.SceneLoader.ImportMesh("", "", "livingRoom//tvShelf.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			newMeshes[0].position.x=30;
			newMeshes[0].position.y=0;
			newMeshes[0].position.z=-40;
			newMeshes[0].checkCollisions=true;
				});
				
			//kithen
			//BABYLON.SceneLoader.ImportMesh("", "", "kitchen//table.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			//for (j = 0; j < newMeshes.length; j++) { 
			//	newMeshes[j].position.x=-50;
			//	newMeshes[j].position.y=0;
			//	newMeshes[j].position.z=-50;
			//	newMeshes[j].checkCollisions=true;
			//	}
			//	});
				
			BABYLON.SceneLoader.ImportMesh("", "", "kitchen//refrig.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			newMeshes[0].position.x=13;
			newMeshes[0].position.y=0;
			 newMeshes[0].position.z=0;
			 newMeshes[0].checkCollisions=true;
				});
				
			BABYLON.SceneLoader.ImportMesh("", "", "kitchen//oven.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			newMeshes[0].position.x=13;
			newMeshes[0].position.y=0;
			 newMeshes[0].position.z=0;
			 newMeshes[0].checkCollisions=true;
				});
			
			BABYLON.SceneLoader.ImportMesh("", "", "kitchen//chair.babylon", scene, function (newMeshes) {
			// Set the target of the camera to the first imported mesh
			newMeshes[0].position.x=13;
			newMeshes[0].position.y=0;
			 newMeshes[0].position.z=0;
			 newMeshes[0].checkCollisions=true;
				});
			
			// createSnow
			// Create a particle system
		var particleSystem = new BABYLON.ParticleSystem("particles", 4500, scene);
		//Texture of each particle
		particleSystem.particleTexture = new BABYLON.Texture("textures/flare.png", scene);
		// Where the particles come from
		particleSystem.emitter =  new BABYLON.Vector3(0, 80, 0);; // the starting object, the emitter
		particleSystem.minEmitBox = new BABYLON.Vector3(-100, 0, -100); // Starting all from
		particleSystem.maxEmitBox = new BABYLON.Vector3(100, 5, 100); // To...
		// Colors of all particles
		particleSystem.color1 = new BABYLON.Color4(0.2, 0.2, 0.2, 0.2);
		particleSystem.color2 = new BABYLON.Color4(0.5, 0.5, 0.5, 0.2);
		particleSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);
		// Size of each particle (random between...
		particleSystem.minSize = 1.0;
		particleSystem.maxSize = 5.0;
		// Life time of each particle (random between...
		particleSystem.minLifeTime = 5;
		particleSystem.maxLifeTime = 10;
		// Emission rate
		particleSystem.emitRate = 1500;
		// Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
		particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
		// Set the gravity of all particles
		particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);
		// Direction of each particle after it has been emitted
		particleSystem.direction1 = new BABYLON.Vector3(-100, 1, -100);
		particleSystem.direction2 = new BABYLON.Vector3(100, 1, 100);
		// Angular speed, in radians
		particleSystem.minAngularSpeed = 0;
		particleSystem.maxAngularSpeed = Math.PI;
		// Speed
		particleSystem.minEmitPower = 1;
		particleSystem.maxEmitPower = 3;
		particleSystem.updateSpeed = 0.002;
		// implement updatefunction
		particleSystem.updateFunction = function(particles) {
			for (var index = 0; index < particles.length; index++) {
           var particle = particles[index];
           particle.age += this._scaledUpdateSpeed;
			
           if (particle.age >= particle.lifeTime || particle.position.y<plane.position.y+1) { // Recycle
                particles.splice(index, 1);
                this._stockParticles.push(particle);
                index--;
                continue;
           }
           else {
                particle.colorStep.scaleToRef(this._scaledUpdateSpeed, this._scaledColorStep);
                particle.color.addInPlace(this._scaledColorStep);
                if (particle.color.a < 0)
                             particle.color.a = 0;
                particle.angle += particle.angularSpeed * this._scaledUpdateSpeed;
                particle.direction.scaleToRef(this._scaledUpdateSpeed, this._scaledDirection);
                particle.position.addInPlace(this._scaledDirection);
                this.gravity.scaleToRef(this._scaledUpdateSpeed, this._scaledGravity);
                particle.direction.addInPlace(this._scaledGravity);
           }
     } 
		};
			// Start the particle system
			particleSystem.start();			
			// ----------------
			// FireCamp
			//Smoke
			var smokeSystem = new BABYLON.ParticleSystem("particless", 2000, scene);
			smokeSystem.particleTexture = new BABYLON.Texture("textures/flare.png", scene);
			smokeSystem.emitter    = new BABYLON.Vector3(80, -6, -120);
			smokeSystem.minEmitBox = new BABYLON.Vector3(-1, 1, -1); // Starting all from
			smokeSystem.maxEmitBox = new BABYLON.Vector3(1, 1, 1); // To...
			
			smokeSystem.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 1.0);
			smokeSystem.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 1.0);
			smokeSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);
			
			smokeSystem.minSize = 0.5;
			smokeSystem.maxSize = 2;
			smokeSystem.minLifeTime = 0.3;
			smokeSystem.maxLifeTime = 1.5;
			smokeSystem.emitRate = 500;
			// Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
			smokeSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
			smokeSystem.gravity = new BABYLON.Vector3(0, 0, 0);
			smokeSystem.direction1 = new BABYLON.Vector3(0, 8, 0);
			smokeSystem.direction2 = new BABYLON.Vector3(0, 8, 0);
			smokeSystem.minAngularSpeed = 0;
			   smokeSystem.maxAngularSpeed = Math.PI;
			smokeSystem.minEmitPower = 1;
			smokeSystem.maxEmitPower = 2;
			smokeSystem.updateSpeed = 0.005;
			smokeSystem.start();
			
			
			
			// Create a particle system
			var fireSystem = new BABYLON.ParticleSystem("particlesf", 2000, scene);
			//Texture of each particle
			fireSystem.particleTexture = new BABYLON.Texture("textures/flare.png", scene);
			// Where the particles come from
			fireSystem.emitter =   new BABYLON.Vector3(80, -6, -120); // the starting object, the emitter
			fireSystem.minEmitBox = new BABYLON.Vector3(-0.5, 1, -0.5); // Starting all from
			fireSystem.maxEmitBox = new BABYLON.Vector3(0.5, 1, 0.5); // To...
			// Colors of all particles
			fireSystem.color1 = new BABYLON.Color4(1, 0.5, 0, 1.0);
			fireSystem.color2 = new BABYLON.Color4(1, 0.5, 0, 1.0);
			fireSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0.0);
			// Size of each particle (random between...
			fireSystem.minSize = 0.5;
			fireSystem.maxSize = 1;
			// Life time of each particle (random between...
			fireSystem.minLifeTime = 0.2;
			fireSystem.maxLifeTime = 0.4;
			// Emission rate
			fireSystem.emitRate = 500;
			// Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
			fireSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
			// Set the gravity of all particles
			fireSystem.gravity = new BABYLON.Vector3(0, 0, 0);
			// Direction of each particle after it has been emitted
			fireSystem.direction1 = new BABYLON.Vector3(0, 8, 0);
			fireSystem.direction2 = new BABYLON.Vector3(0, 8, 0);
			// Angular speed, in radians
			fireSystem.minAngularSpeed = 0;
			fireSystem.maxAngularSpeed = Math.PI;
			// Speed
			fireSystem.minEmitPower = 1;
			fireSystem.maxEmitPower = 3;
			fireSystem.updateSpeed = 0.005;
			// Start the particle system
			fireSystem.start();
			//------------
			//Ground
			// Window ---------------
            /*var window =    BABYLON.Mesh.CreatePlane("window", 10, scene);
			var windowMaterial = new BABYLON.StandardMaterial("windowTexture", scene);
			windowMaterial.diffuseColor = new BABYLON.Color3(1, 0.6, 0.4);
			windowMaterial.reflectionTexture = new BABYLON.MirrorTexture("window", 512, scene, true); //Create a mirror texture
			windowMaterial.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0.0,0.0, -10.0);
			//windowMaterial.reflectionTexture.mirrorPlane = scene.getMeshByID("plane");
			windowMaterial.reflectionTexture.renderList = [plane,skybox];
			windowMaterial.reflectionTexture.level = 0.6;//Select the level (0.0 > 1.0) of the reflection
			 window.position.z = 50;
             window.position.y = -1;
            // window.rotation.x = -Math.PI/2;
			 window.material = windowMaterial;*/
			// -----------------------
			// Mirror
    // Mirror
	
    // MATERIALS
		var simpleMaterial = new BABYLON.StandardMaterial("texture2", scene);
		simpleMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0);//Red
		//Creation of a mirror material Vertical
		var mirrorMaterial = new BABYLON.StandardMaterial("texture4", scene);
		mirrorMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
		mirrorMaterial.reflectionTexture = new BABYLON.MirrorTexture("mirror", 512, scene, true); //Create a mirror texture
		mirrorMaterial.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0, -1.0, -10.0);
		mirrorMaterial.reflectionTexture.renderList = [plane,skybox];
		mirrorMaterial.reflectionTexture.level = 0.6;//Select the level (0.0 > 1.0) of the reflection
		//Applying materials
		// clone mirror
		var mirror = BABYLON.Mesh.CreatePlane("mirror", 20, scene);
		mirror.position.y +=6;
		mirror.position.z -=15;
		mirror.rotate(BABYLON.Axis.X, 3.14, BABYLON.Space.LOCAL);
		mirror.material = mirrorMaterial;
			// Window ---------------
			var window = BABYLON.Mesh.CreatePlane("mirror", 20, scene);
				window.rotate(BABYLON.Axis.X, 3.14, BABYLON.Space.LOCAL);
				window.position.x -=20;
				window.position.y +=6;
				window.position.z -=15;
			windowMaterial  = mirrorMaterial.clone("window");
			windowMaterial.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0, 0.0, -10.0);
			window.material = windowMaterial;
			//------------
	//----fountainobj----//
		/*var ftex = new BABYLON.StandardMaterial("ftex", scene);
		var ftex = new BABYLON.MarbleProceduralTexture("ftex", 512, scene);
		ftex.numberOfBricksHeight = 5;
		ftex.numberOfBricksWidth = 5;
		ftex.ambientTexture = marbleTexture;*/
		var ft = BABYLON.Mesh.CreateTorus("ft", 35, 4, 6, scene);
		ft.position = new BABYLON.Vector3(-100, -5, -100);
		//ft.material = marbleMaterial;
		var fg = BABYLON.Mesh.CreateCylinder("cylinder", 0.01, 35, 35, 6, 1, scene, false);
		fg.position = new BABYLON.Vector3(-100, -5, -100);
		fg.rotation = new BABYLON.Vector3( 0, Math.PI /2, 0);
		var wt =  new WaterMaterial("wt", scene, light);
		wt.bumpTexture = new BABYLON.Texture("textures/waterbump.png", scene);
		wt.windForce = -10;
		wt.waveHeight = 0.5;
		wt.windDirection = new BABYLON.Vector2(-0.5, 1);
		wt.waterColor = new BABYLON.Color3(0.6, 0.6, 0.9);
		wt.colorBlendFactor = 0.8;
		wt.bumpHeight = 0.1;
		wt.waveLength = 0.1;
		wt.reflectionTexture.renderList.push(plane);				
		wt.reflectionTexture.renderList.push(skybox);
		fg.material=wt;
        //fontainGround.material = marbleMaterial;
	//----fountaineffect----//
		var fountain = BABYLON.Mesh.CreateBox("fountain",0.1,scene);
		fountain.position=new BABYLON.Vector3(-100,-5,-100);
		var particleSystemx = new BABYLON.ParticleSystem("particles", 4000, scene);
		var particleSystemz = new BABYLON.ParticleSystem("particles", 4000, scene);
		particleSystemx.particleTexture = new BABYLON.Texture("textures/bubble.png", scene);
		particleSystemz.particleTexture = new BABYLON.Texture("textures/bubble.png", scene);
	
		particleSystemx.emitter = fountain; // the starting object, the emitter
		particleSystemx.minEmitBox = new BABYLON.Vector3(0, 1, 0); // Starting all from
		particleSystemx.maxEmitBox = new BABYLON.Vector3(0, 1, 0); // To...
		particleSystemz.emitter = fountain;
		particleSystemz.minEmitBox = new BABYLON.Vector3(0, 1, 0);
		particleSystemz.maxEmitBox = new BABYLON.Vector3(0, 1, 0);
		
		particleSystemx.color1 = new BABYLON.Color4(0.1, 0.1, 0.1,0.001);
		particleSystemx.color2 = new BABYLON.Color4(0.1,0.1, 0.1, 0.001);
		particleSystemx.colorDead = new BABYLON.Color4(0.1, 0.1, 0.1, 0.0);
		particleSystemz.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		particleSystemz.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		particleSystemz.colorDead = new BABYLON.Color4(0.1, 0.1, 0.1, 0.0);
		particleSystemx.minSize = 0.1;
		particleSystemx.maxSize = 1;
		particleSystemz.minSize = 0.1;
		particleSystemz.maxSize = 1;
		particleSystemx.minLifeTime = 0.3;
		particleSystemx.maxLifeTime =10.0;
		particleSystemz.minLifeTime = 0.3;
		particleSystemz.maxLifeTime = 10.0;
		particleSystemx.emitRate = 3000;
		particleSystemz.emitRate = 3000;
		particleSystemx.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
		particleSystemz.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
 
		particleSystemx.gravity = new BABYLON.Vector3(0, -19.81, 0);
		particleSystemz.gravity = new BABYLON.Vector3(0, -19.81, 0);
   
		particleSystemx.direction1 = new BABYLON.Vector3(3,10, 0);
		particleSystemx.direction2 = new BABYLON.Vector3(-3, 10, 0);
		particleSystemz.direction1 = new BABYLON.Vector3(0,10, 3);
		particleSystemz.direction2 = new BABYLON.Vector3(0, 10, -3);
		particleSystemx.minAngularSpeed = 1;
		particleSystemx.maxAngularSpeed = Math.PI;
		particleSystemz.minAngularSpeed = 1;
		particleSystemz.maxAngularSpeed = Math.PI;
		particleSystemx.minEmitPower = 2.25;
		particleSystemx.maxEmitPower = 2.5;
		particleSystemx.updateSpeed = 0.03;
		particleSystemz.minEmitPower = 2.25;
		particleSystemz.maxEmitPower = 2.5;
		particleSystemz.updateSpeed = 0.03;
		particleSystemx.start();
		particleSystemz.start();
		// Fountain's animation
		var keys = [];
		var animation = new BABYLON.Animation("animation", "rotation.y", 360, BABYLON.Animation.ANIMATIONTYPE_FLOAT,
		BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE );																	
		// At the animation key 0, the value of scaling is "1"
		keys.push({
        frame: 0,
        value: 0
		});
		// At the animation key 50, the value of scaling is "0.2"
		keys.push({
        frame: 50,
        value: Math.PI
		});
		// At the animation key 100, the value of scaling is "1"
		keys.push({
        frame: 100,
        value: 0
		});
		// Launch animation
		animation.setKeys(keys);
		fountain.animations.push(animation);
		scene.beginAnimation(fountain, 0, 100, true);
	//-----fountain effect end-----//
		
	//----fountain path----//
		var p1 = new BABYLON.Vector3(20, -5, -100);
		var p2 = new BABYLON.Vector3(-20, -5, -110);
		var p3 = new BABYLON.Vector3(20, -5, -120);
		var p4 = new BABYLON.Vector3(-20, -5, -130);
		var p5 = new BABYLON.Vector3(20, -5, -140);
		var p6 = new BABYLON.Vector3(-20, -5, -150);
		// Create a particle system
		var a1 = new BABYLON.ParticleSystem("particles", 2000, scene);
		var a2	= new BABYLON.ParticleSystem("particles", 2000, scene);
		var a3 = new BABYLON.ParticleSystem("particles", 2000, scene);
		var a4 = new BABYLON.ParticleSystem("particles", 2000, scene);
		var a5 = new BABYLON.ParticleSystem("particles", 2000, scene);
		var a6 = new BABYLON.ParticleSystem("particles", 2000, scene);
		//Texture of each particle
		a1.particleTexture = new BABYLON.Texture("textures/bubble.png", scene);
		a2.particleTexture = new BABYLON.Texture("textures/bubble.png", scene);
		a3.particleTexture = new BABYLON.Texture("textures/bubble.png", scene);
		a4.particleTexture = new BABYLON.Texture("textures/bubble.png", scene);
		a5.particleTexture = new BABYLON.Texture("textures/bubble.png", scene);
		a6.particleTexture = new BABYLON.Texture("textures/bubble.png", scene);
		// Where the particles come from
		a1.emitter = p1;
		a1.minEmitBox = new BABYLON.Vector3(0, 0, 0);
		a2.emitter = p2;
		a2.minEmitBox = new BABYLON.Vector3(0, 0, 0);
		a3.emitter = p3;
		a3.minEmitBox = new BABYLON.Vector3(0, 0, 0);
		a4.emitter = p4;
		a4.minEmitBox = new BABYLON.Vector3(0, 0, 0);
		a5.emitter = p5;
		a5.minEmitBox = new BABYLON.Vector3(0, 0, 0);
		a6.emitter = p6;
		a6.minEmitBox = new BABYLON.Vector3(0, 0, 0);
	
		// Colors of all particles
		a1.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a1.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a1.colorDead = new BABYLON.Color4(0.1, 0.1, 0.1, 0.0);
		a2.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a2.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a2.colorDead = new BABYLON.Color4(0.1, 0.1, 0.1, 0.0);
		a3.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a3.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a3.colorDead = new BABYLON.Color4(0.1, 0.1, 0.1, 0.0);
		a4.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a4.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a4.colorDead = new BABYLON.Color4(0.1, 0.1, 0.1, 0.0);
		a5.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a5.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a5.colorDead = new BABYLON.Color4(0.1, 0.1, 0.1, 0.0);
		a6.color1 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a6.color2 = new BABYLON.Color4(0.1, 0.1, 0.1, 0.001);
		a6.colorDead = new BABYLON.Color4(0.1, 0.1, 0.1, 0.0);
		
		// Size of each particle (random between...
		a1.minSize = 1.0;
		a2.minSize = 1.0;
		a3.minSize = 1.0;
		a4.minSize = 1.0;
		a5.minSize = 1.0;
		a6.minSize = 1.0;
	
		// Life time of each particle (random between...
		a1.minLifeTime = 8.0;
		a2.minLifeTime = 8.0;
		a3.minLifeTime = 8.0;
		a4.minLifeTime = 8.0;
		a5.minLifeTime = 8.0;
		a6.minLifeTime = 8.0;
		//particleSystem.maxLifeTime = 1.5;
	
		// Emission rate
		a1.emitRate = 300;
		a2.emitRate = 300;
		a3.emitRate = 300;
		a4.emitRate = 300;
		a5.emitRate = 300;
		a6.emitRate = 300;
	
		// Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
		a1.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
		a2.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
		a3.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
		a4.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
		a5.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
		a6.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
	
		// Set the gravity of all particles
		a1.gravity = new BABYLON.Vector3(0, -9.81, 0);
		a2.gravity = new BABYLON.Vector3(0, -9.81, 0);
		a3.gravity = new BABYLON.Vector3(0, -9.81, 0);
		a4.gravity = new BABYLON.Vector3(0, -9.81, 0);
		a5.gravity = new BABYLON.Vector3(0, -9.81, 0);
		a6.gravity = new BABYLON.Vector3(0, -9.81, 0);
			
		// Direction of each particle after it has been emitted
		a1.direction1 = new BABYLON.Vector3(-3.5, 12, 0);
		a1.direction2 = new BABYLON.Vector3(-3.5, 12, 0);
		a2.direction1 = new BABYLON.Vector3(3.5, 12, 0);
		a2.direction2 = new BABYLON.Vector3(3.5, 12, 0);
		a3.direction1 = new BABYLON.Vector3(-3.5, 12, 0);
		a3.direction2 = new BABYLON.Vector3(-3.5, 12, 0);
		a4.direction1 = new BABYLON.Vector3(3.5, 12, 0);
		a4.direction2 = new BABYLON.Vector3(3.5, 12, 0);
		a5.direction1 = new BABYLON.Vector3(-3.5, 12, 0);
		a5.direction2 = new BABYLON.Vector3(-3.5, 12, 0);
		a6.direction1 = new BABYLON.Vector3(3.5, 12, 0);
		a6.direction2 = new BABYLON.Vector3(3.5, 12, 0);
	
		// Angular speed, in radians
		a1.minAngularSpeed = 1;
		a1.maxAngularSpeed = Math.PI;
		a2.minAngularSpeed = 1;
		a2.maxAngularSpeed = Math.PI;
		a3.minAngularSpeed = 1;
		a3.maxAngularSpeed = Math.PI;
		a4.minAngularSpeed = 1;
		a4.maxAngularSpeed = Math.PI;
		a5.minAngularSpeed = 1;
		a5.maxAngularSpeed = Math.PI;
		a6.minAngularSpeed = 1;
		a6.maxAngularSpeed = Math.PI;
	
		// Speed
		a1.minEmitPower = 1.875;
		a1.maxEmitPower = 2;
		a1.updateSpeed = 0.005;
		a2.minEmitPower = 1.875;
		a2.maxEmitPower = 2;
		a2.updateSpeed = 0.005;
		a3.minEmitPower = 1.875;
		a3.maxEmitPower = 2;
		a3.updateSpeed = 0.005;
		a4.minEmitPower = 1.875;
		a4.maxEmitPower = 2;
		a4.updateSpeed = 0.005;
		a5.minEmitPower = 1.875;
		a5.maxEmitPower = 2;
		a5.updateSpeed = 0.005;
		a6.minEmitPower = 1.875;
		a6.maxEmitPower = 2;
		a6.updateSpeed = 0.005;
	
		// Start the particle system
		a1.start();
		a2.start();
		a3.start();
		a4.start();
		a5.start();
		a6.start();
	//---- fountain path end----//
	//---- fountain path obj---//
	//var path1 = BABYLON.Mesh.CreatePlane("path1", 20, scene);
    var path1 = BABYLON.Mesh.CreateCylinder("cylinder", 2.5, 30, 1, 4, 1, scene, false);
		path1.position = new BABYLON.Vector3(0, -4.5, -100);
	//path1.position.y = -4.5;
	//path1.position.x=0;
	//path1.position.z= -100;
	path1.rotation = new BABYLON.Vector3(0,Math.PI / 4, 0);
	pw1 = mirrorMaterial.clone("window");
	pw1.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0, 0.0, -10.0);
	pw1.color1 = new BABYLON.Color4(255,215,0,0.1)
	path1.material=pw1;
	//var path2 = BABYLON.Mesh.CreatePlane("path1", 20, scene);
    var path2 = BABYLON.Mesh.CreateCylinder("cylinder", 2.5, 30, 1, 4, 1, scene, false);
		path2.position = new BABYLON.Vector3(0, -4.5, -120);
	//path2.position.y = -4.5;
	//path2.position.x=0;
	//path2.position.z= -120;
	path2.rotation = new BABYLON.Vector3(0,Math.PI / 4, 0);
	pw2 = mirrorMaterial.clone("window");
	pw2.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0, 0.0, -10.0);
	path2.material=pw2;
	//var path3 = BABYLON.Mesh.CreatePlane("path2", 20, scene);
	var path3 = BABYLON.Mesh.CreateCylinder("cylinder", 2.5, 30, 1, 4, 1, scene, false);
		path3.position = new BABYLON.Vector3(0, -4.5, -140);
	//path3.position.y = -4.5;
	//path3.position.x=0;
	//path3.position.z= -140;
	path3.rotation = new BABYLON.Vector3(0,Math.PI / 4, 0);
	pw3 = mirrorMaterial.clone("window");
	pw3.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0, 0.0, -10.0);
	path3.material=pw3;
	//var path4 = BABYLON.Mesh.CreatePlane("path3", 20, scene);
	var path4 = BABYLON.Mesh.CreateCylinder("cylinder", 2.5, 30, 1, 4, 1, scene, false);
		path4.position = new BABYLON.Vector3(0, -4.5, -160);
		path4.rotation = new BABYLON.Vector3( 0, Math.PI /4, 0);
	//path4.position.y = -4.5;
	//path4.position.x=0;
	//path4.position.z= -160;
	pw4 = mirrorMaterial.clone("window");
	pw4.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, 0, 0.0, -10.0);
	path4.material=pw4;
	/*var wpath = BABYLON.Mesh.CreatePlane("wpat4", 60, scene);
	wpath.position.y = -5;
	wpath.position.x=-125;
	wpath.position.z= 0;
	wpath.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);*/
	var wpath = BABYLON.Mesh.CreateGround("wpath", 60, 60, 32, scene, false);
	wpath.position.y = -5;
	wpath.position.x=0;
	wpath.position.z= -125;
	wpath.material = wt;
	var gold = new BABYLON.StandardMaterial("gold", scene);
    gold.diffuseColor = new BABYLON.Color3(1.0, 0.836, 0.386);
    gold.reflectionTexture = new BABYLON.MirrorTexture("goldmr", 512, scene, true);
    gold.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, -1.0, 0, -10.0);
    gold.reflectionTexture.renderList = [skybox];
    gold.reflectionTexture.level = 0.6;
	var cwpath = BABYLON.Mesh.CreateTorus("ft", 85, 0.25, 4, scene);
	cwpath.position = new BABYLON.Vector3(0, -5, -125);
	cwpath.rotation = new BABYLON.Vector3( 0, Math.PI /4, 0);
	cwpath.material=gold;
	
	
	//----end fountain path obj---//
	// video 
	 var lightTV = new BABYLON.PointLight("Omni", new BABYLON.Vector3(30.05, 4.65, -38.75), scene);
	 lightTV.intensity= 0.2;
	var videoPlane = BABYLON.Mesh.CreatePlane("Screen", 10.75, scene);
    videoPlane.position.x = 30.05; 
	videoPlane.position.z = -38.75; 
	videoPlane.position.y = 4.65;
	videoPlane.scaling.y= 0.5;
	videoPlane.rotation.y+= Math.PI;
	var videoMat = new BABYLON.StandardMaterial("textVid", scene);
    videoMat.diffuseTexture = new BABYLON.VideoTexture("video", ["textures/Algo.mp4"], scene, false);
	//videoPlane.material=videoMat;
	//-----------
		return scene;
        };
        
        
        var scene = createScene();
        engine.runRenderLoop(function () {
            scene.render();
        });
        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
